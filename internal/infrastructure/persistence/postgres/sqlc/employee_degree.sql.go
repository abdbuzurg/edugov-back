// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: employee_degree.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmployeeDegree = `-- name: CreateEmployeeDegree :one
INSERT INTO employee_degrees(
  employee_id,
  language_code,
  degree_level,
  university_name,
  speciality,
  date_start,
  date_end,
  given_by,
  date_degree_recieved
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, created_at, updated_at
`

type CreateEmployeeDegreeParams struct {
	EmployeeID         int64       `json:"employee_id"`
	LanguageCode       string      `json:"language_code"`
	DegreeLevel        string      `json:"degree_level"`
	UniversityName     string      `json:"university_name"`
	Speciality         string      `json:"speciality"`
	DateStart          pgtype.Date `json:"date_start"`
	DateEnd            pgtype.Date `json:"date_end"`
	GivenBy            pgtype.Text `json:"given_by"`
	DateDegreeRecieved pgtype.Date `json:"date_degree_recieved"`
}

type CreateEmployeeDegreeRow struct {
	ID        int64              `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateEmployeeDegree(ctx context.Context, arg CreateEmployeeDegreeParams) (CreateEmployeeDegreeRow, error) {
	row := q.db.QueryRow(ctx, createEmployeeDegree,
		arg.EmployeeID,
		arg.LanguageCode,
		arg.DegreeLevel,
		arg.UniversityName,
		arg.Speciality,
		arg.DateStart,
		arg.DateEnd,
		arg.GivenBy,
		arg.DateDegreeRecieved,
	)
	var i CreateEmployeeDegreeRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteEmployeeDegree = `-- name: DeleteEmployeeDegree :exec
DELETE FROM employee_degrees
WHERE id = $1
`

func (q *Queries) DeleteEmployeeDegree(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEmployeeDegree, id)
	return err
}

const getEmployeeDegreeByID = `-- name: GetEmployeeDegreeByID :one
SELECT id, employee_id, language_code, university_name, degree_level, speciality, date_start, date_end, given_by, date_degree_recieved, created_at, updated_at
FROM employee_degrees
WHERE id = $1
`

func (q *Queries) GetEmployeeDegreeByID(ctx context.Context, id int64) (EmployeeDegree, error) {
	row := q.db.QueryRow(ctx, getEmployeeDegreeByID, id)
	var i EmployeeDegree
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.LanguageCode,
		&i.UniversityName,
		&i.DegreeLevel,
		&i.Speciality,
		&i.DateStart,
		&i.DateEnd,
		&i.GivenBy,
		&i.DateDegreeRecieved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeDegreesByEmployeeIDAndLanguageCode = `-- name: GetEmployeeDegreesByEmployeeIDAndLanguageCode :many
SELECT id, employee_id, language_code, university_name, degree_level, speciality, date_start, date_end, given_by, date_degree_recieved, created_at, updated_at
FROM employee_degrees
WHERE employee_id = $1 AND language_code = $2
`

type GetEmployeeDegreesByEmployeeIDAndLanguageCodeParams struct {
	EmployeeID   int64  `json:"employee_id"`
	LanguageCode string `json:"language_code"`
}

func (q *Queries) GetEmployeeDegreesByEmployeeIDAndLanguageCode(ctx context.Context, arg GetEmployeeDegreesByEmployeeIDAndLanguageCodeParams) ([]EmployeeDegree, error) {
	rows, err := q.db.Query(ctx, getEmployeeDegreesByEmployeeIDAndLanguageCode, arg.EmployeeID, arg.LanguageCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmployeeDegree{}
	for rows.Next() {
		var i EmployeeDegree
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.LanguageCode,
			&i.UniversityName,
			&i.DegreeLevel,
			&i.Speciality,
			&i.DateStart,
			&i.DateEnd,
			&i.GivenBy,
			&i.DateDegreeRecieved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployeeDegree = `-- name: UpdateEmployeeDegree :one
UPDATE employee_degrees 
SET 
  degree_level = COALESCE($1, degree_level),
  university_name = COALESCE($2, university_name),
  speciality = COALESCE($3, speciality),
  date_start = COALESCE($4, date_start),
  date_end = COALESCE($5, date_end),
  given_by = COALESCE($6, given_by),
  date_degree_recieved = COALESCE($7, date_degree_recieved),
  updated_at = now()
WHERE id = $8
RETURNING id, created_at, updated_at
`

type UpdateEmployeeDegreeParams struct {
	DegreeLevel        string      `json:"degree_level"`
	UniversityName     string      `json:"university_name"`
	Speciality         string      `json:"speciality"`
	DateStart          pgtype.Date `json:"date_start"`
	DateEnd            pgtype.Date `json:"date_end"`
	GivenBy            pgtype.Text `json:"given_by"`
	DateDegreeRecieved pgtype.Date `json:"date_degree_recieved"`
	ID                 int64       `json:"id"`
}

type UpdateEmployeeDegreeRow struct {
	ID        int64              `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateEmployeeDegree(ctx context.Context, arg UpdateEmployeeDegreeParams) (UpdateEmployeeDegreeRow, error) {
	row := q.db.QueryRow(ctx, updateEmployeeDegree,
		arg.DegreeLevel,
		arg.UniversityName,
		arg.Speciality,
		arg.DateStart,
		arg.DateEnd,
		arg.GivenBy,
		arg.DateDegreeRecieved,
		arg.ID,
	)
	var i UpdateEmployeeDegreeRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}
